
NumPy — библиотека с открытым исходным кодом для языка программирования Python. 
Возможности:
- поддержка многомерных массивов (включая матрицы);
- поддержка высокоуровневых математических функций, предназначенных для работы с многомерными массивами.

#### Назначение
Математические алгоритмы, реализованные на интерпретируемых языках (например, Python), часто работают гораздо медленнее тех же алгоритмов, реализованных на компилируемых языках (например, Фортран, Си, Java). Библиотека NumPy предоставляет реализации вычислительных алгоритмов (в виде функций и операторов), оптимизированные для работы с многомерными массивами. В результате любой алгоритм, который может быть выражен в виде последовательности операций над массивами (матрицами) и реализованный с использованием NumPy, работает так же быстро, как эквивалентный код, выполняемый в MATLAB[2].

#### Сравнение с MATLAB
NumPy можно рассматривать как свободную альтернативу MATLAB. Язык программирования MATLAB внешне напоминает NumPy: оба они интерпретируемые, оба позволяют выполнять операции над массивами (матрицами), а не над скалярами. Преимущество MATLAB в наличии большого количества пакетов («тулбоксов»), например, Simulink (англ.). Для NumPy тоже существуют подобные «пакеты», например, библиотека SciPy предоставляет больше MATLAB-подобной функциональности, библиотека Matplotlib позволяет создавать графики в стиле MATLAB. И MATLAB, и NumPy для решения основных задач линейной алгебры используют код, основанный на коде библиотеки LAPACK.



# NumPy

Импорт модуля numpy:


```python
import numpy

import numpy as np

from numpy import *
```

#### Массивы

Главной особенностью numpy является объект array. Массивы схожи со списками в python, исключая тот факт, что элементы массива должны иметь одинаковый тип данных, как float и int. С массивами можно проводить числовые операции с большим объемом информации в разы быстрее и, главное, намного эффективнее чем со списками. 

Создание массива из списка:


```python
import numpy as np
a = np.array([1, 4, 5, 8], float)
```


```python
a
```




    array([1., 4., 5., 8.])




```python
type(a)
```




    numpy.ndarray



Здесь функция array принимает два аргумента: список для конвертации в массив и тип для каждого элемента. Ко всем элементам можно получить доступ и манипулировать ими также, как вы бы это делали с обычными списками:


```python
a[:2]
```




    array([1., 4.])




```python
 a[3]
```




    8.0




```python
a[0] = 5.
a
```




    array([5., 4., 5., 8.])



Массивы могут быть и многомерными. В отличии от списков можно задавать команды в скобках. Вот пример двумерного массива (матрица):


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
a
```




    array([[1., 2., 3.],
           [4., 5., 6.]])




```python
a[0,0]
```




    1.0




```python
a[0,1]
```




    2.0



Array slicing работает с многомерными массивами аналогично, как и с одномерными, применяя каждый срез, как фильтр для установленного измерения. Используйте ":" в измерении для указывания использования всех элементов этого измерения:


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
a[1,:]
```




    array([4., 5., 6.])




```python
a[:,2]
```




    array([3., 6.])




```python
a[-1:, -2:]
```




    array([[5., 6.]])



Метод shape возвращает количество строк и столбцов в матрице:


```python
a.shape
```




    (2, 3)



Метод dtype возвращает тип переменных, хранящихся в массиве:


```python
a.dtype
```




    dtype('float64')



Тут float64, это числовой тип данных в numpy, который используется для хранения вещественных чисел двойной точности. Так как же float в Python.

Метод len возвращает длину первого измерения (оси):


```python
len(a)
```




    2



Метод in используется для проверки на наличие элемента в массиве:


```python
2 in a
```




    True




```python
0 in a
```




    False



Массивы можно переформировать при помощи метода, который задает новый многомерный массив. Следуя следующему примеру, мы переформатируем одномерный массив из десяти элементов во двумерный массив, состоящий из пяти строк и двух столбцов:


```python
a = np.array(range(10), float)
a
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])




```python
a = a.reshape((5, 2))
a
```




    array([[0., 1.],
           [2., 3.],
           [4., 5.],
           [6., 7.],
           [8., 9.]])




```python
a.shape
```




    (5, 2)



Связывание имен в python работает и с массивами. Метод copy используется для создания копии существующего массива в памяти:



```python
a = np.array([1, 2, 3], float)
b = a
c =  a.copy()
a[0] = 0
a
```




    array([0., 2., 3.])




```python
b
```




    array([0., 2., 3.])




```python
c
```




    array([1., 2., 3.])



Списки можно тоже создавать с массивов:


```python
a = np.array([1, 2, 3], float)
a.tolist()
```




    [1.0, 2.0, 3.0]




```python
list(a)
```




    [1.0, 2.0, 3.0]



Размерность массива может быть увеличена при использовании константы newaxis в квадратных скобках:


```python
a = np.array([1, 2, 3], float)
a
```




    array([1., 2., 3.])




```python
a[:,np.newaxis]
```




    array([[1.],
           [2.],
           [3.]])




```python
a[:,np.newaxis].shape
```




    (3, 1)




```python
b[np.newaxis,:]
```




    array([[0., 2., 3.]])




```python
b[np.newaxis,:].shape
```




    (1, 3)



#### Другие пути создания массивов

Функция arange аналогична функции range, но возвращает массив:


```python
np.arange(5, dtype=float)
```




    array([0., 1., 2., 3., 4.])




```python
np.arange(1, 6, 2, dtype=int)
```




    array([1, 3, 5])



Для создания квадратной матрицы с главной диагональю, которая заполненная единицами, воспользуемся методом identity:


```python
np.identity(4, dtype=float)
```




    array([[1., 0., 0., 0.],
           [0., 1., 0., 0.],
           [0., 0., 1., 0.],
           [0., 0., 0., 1.]])



Функция eye возвращает матрицу с единичками на к-атой диагонали:


```python
np.eye(4, k=1, dtype=float)
```




    array([[0., 1., 0., 0.],
           [0., 0., 1., 0.],
           [0., 0., 0., 1.],
           [0., 0., 0., 0.]])



Когда для массивов мы используем стандартные математические операции, должен соблюдаться принцип: элемент--элемент. Это означает, что массивы должны быть одинакового размера во время сложения, вычитания и тому подобных операций:


```python
a = np.array([1,2,3], float)
b = np.array([5,2,6], float)
a + b
```




    array([6., 4., 9.])



Вдобавок к стандартным операторам, в numpy включена библиотека стандартных математических функций, которые могут быть применены поэлементно к массивам. Собственно функции: abs, sign, sqrt, log, log10, exp, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, и arctanh.


```python
a = np.array([1, 4, 9], float)
np.sqrt(a)
```




    array([1., 2., 3.])



Функции floor, ceil и rint возвращают нижние, верхние или ближайшие (округлённое) значение:


```python
a = np.array([1.1, 1.5, 1.9], float)
np.floor(a)
```




    array([1., 1., 1.])




```python
np.ceil(a)
```




    array([2., 2., 2.])




```python
np.rint(a)
```




    array([1., 2., 2.])



#### Базовые операции над массивами

Для получения каких-либо свойств массивов существует много функций. Элементы могут быть суммированы или перемножены:



```python
a = np.array([2, 4, 3], float)
a.sum()
```




    9.0




```python
a.prod()
```




    24.0



Для большинства случаев могут использоваться оба варианта. 
Некие функции дают возможность оперировать статистическими данными. Это функции mean (среднее арифметическое), вариация и девиация:


```python
a = np.array([2, 1, 9], float)
a.mean()
```




    4.0




```python
a.var()
```




    12.666666666666666




```python
a.std()
```




    3.559026084010437




```python
a.min()
```




    1.0




```python
a.max()
```




    9.0




```python
a.argmin()
```




    1




```python
a.argmax()
```




    2



Как и списки, массивы можно отсортировать:


```python
a = np.array([6, 2, 5, -1, 0], float)
```


```python
sorted(a)
```




    [-1.0, 0.0, 2.0, 5.0, 6.0]




```python
a.sort()
```


```python
a
```




    array([-1.,  0.,  2.,  5.,  6.])




```python
a.clip(0, 5)
```




    array([0., 0., 2., 5., 5.])




```python
a = np.array([1, 1, 4, 5, 5, 5, 7], float)
np.unique(a)
```




    array([1., 4., 5., 7.])




```python
a = np.array([[1, 2], [3, 4]], float)
a.diagonal()
```




    array([1., 4.])



#### Операторы сравнения и тестирование значений

Булево сравнение может быть использовано для поэлементного сравнения массивов одинаковых длин. Возвращаемое значение это массив булевых True/False значений:



```python
a = np.array([1, 3, 0], float)
b = np.array([0, 3, 2], float)
a > b
```




    array([ True, False, False])




```python
a == b
```




    array([False,  True, False])




```python
a <= b
```




    array([False,  True,  True])




```python
c = a > b
```


```python
c
```




    array([ True, False, False])




```python
a = np.array([1, 3, 0], float)
a > 2
```




    array([False,  True, False])



Операторы any и all могут быть использованы для определения истинны ли хотя бы один или все элементы соответственно:


```python
c = np.array([ True, False, False], bool)
any(c)
```




    True




```python
all(c)
```




    False



Функция where создает новый массив из двух других массивов одинаковых длин используя булев фильтр для выбора межу двумя элементами. Базовый синтаксис: where(boolarray, 
truearray, falsearray):


```python
a = np.array([1, 3, 0], float)
np.where(a != 0, 1 / a, a)
```

    /anaconda3/lib/python3.6/site-packages/ipykernel_launcher.py:2: RuntimeWarning: divide by zero encountered in true_divide
      





    array([1.        , 0.33333333, 0.        ])




```python
np.where(a > 0, 3, 2)
```




    array([3, 3, 2])



#### Выбор элементов массива и манипуляция с ними

Мы уже видели, как и у списков, элементы массива можно получить используя операцию доступа по индексу. Однако, в отличии от списков, массивы также позволяют делать выбор элементов используя другие массивы. Это значит, что мы можем использовать массив для фильтрации специфических подмножеств элементов других массивов. 

Булевы массивы могут быть использованы как массивы для фильтрации: 


```python
a = np.array([[6, 4], [5, 9]], float)
a >= 6
```




    array([[ True, False],
           [False,  True]])




```python
a[a >= 6]
```




    array([6., 9.])



Стоит заметить, что когда мы передаем булев массив a>=6 как индекс для операции доступа по индексу массива a, возвращаемый массив будет хранить только True значения. Также мы можем записать массив для фильтрации в переменную:


```python
sel = (a >= 6)
a[sel]
```




    array([6., 9.])




```python
a = np.array([2, 4, 6, 8], float)
b = np.array([0, 0, 1, 3, 2, 1], int)
a[b]
```




    array([2., 2., 4., 8., 6., 4.])




```python
a = np.array([[0, 1], [2, 3]], float)
b = np.array([0, 0, 1], int)
a.take(b, axis=0)
```




    array([[0., 1.],
           [0., 1.],
           [2., 3.]])




```python
a.take(b, axis=1)
```




    array([[0., 0., 1.],
           [2., 2., 3.]])



Векторная и матричная математика

NumPy обеспечивает много функций для работы с векторами и матрицами. Функция dot возвращает скалярное произведение векторов:


```python
a = np.array([1, 2, 3], float)
b = np.array([0, 1, 1], float)
np.dot(a, b)
```




    5.0




```python
a = np.array([[0, 1], [2, 3]], float)
b = np.array([2, 3], float)
c = np.array([[1, 1], [4, 0]], float)
a
```




    array([[0., 1.],
           [2., 3.]])




```python
np.dot(b, a)
```




    array([ 6., 11.])



Также можно получить скалярное, тензорное и внешнее произведение матриц и векторов. Заметим, что для векторов внутреннее и скалярное произведение совпадает. 


```python
a = np.array([1, 4, 0], float)
b = np.array([2, 2, 1], float)
np.outer(a, b)
```




    array([[2., 2., 1.],
           [8., 8., 4.],
           [0., 0., 0.]])




```python
np.inner(a, b)
```




    10.0




```python
np.cross(a, b)
```




    array([ 4., -1., -6.])



#### Математика многочленов

NumPy предоставляет методы для работы с полиномами. Передавая список корней, можно получить коэффициенты уравнения:


```python
np.poly([-1, 1, 1, 10])
```




    array([  1., -11.,   9.,  11., -10.])



Здесь, массив возвращает коэффициенты соответствующие уравнению.

Может быть произведена и обратная операция: передавая список коэффициентов, функция root вернет все корни многочлена:


```python
np.roots([1, 4, -2, 3])
```




    array([-4.5797401 +0.j        ,  0.28987005+0.75566815j,
            0.28987005-0.75566815j])



Заметим, что в этом уравнении два корня мнимые. Коэффициенты многочлена могут быть интегрированы. Обычно константа C равна нулю.


```python
np.polyint([1, 1, 1, 1])
```




    array([0.25      , 0.33333333, 0.5       , 1.        , 0.        ])



или


```python
np.polyder([1./4., 1./3., 1./2., 1., 0.])
```




    array([1., 1., 1., 1.])



Статистика

NumPy предоставляет еще некоторые методы для работы со статистическими данными в массивах.

Медиана может быть найдена так:


```python
a = np.array([1, 4, 3, 8, 9, 2, 3], float)
np.median(a)
```




    3.0



Коэффициент корреляции для некоторых переменных, наблюдается несколько раз и может быть найден из массивов вида: [[x1, x2, ...], [y1, y2, ...], [z1, z2, ...], ...], где x, y, z это разные квантовые наблюдаемые и номера указывают количество «наблюдений»:


```python
a = np.array([[1, 2, 1, 3], [5, 3, 1, 8]], float)
c = np.corrcoef(a)
c
```




    array([[1.        , 0.72870505],
           [0.72870505, 1.        ]])



Случайные числа

Важная часть каждой симуляции это способность генерировать случайные числа. Для этого мы используем встроенный в NumPy генератор псевдослучайных чисел в под-модуле random. Числа являются псевдо случайными, в том плане что, они сгенерированы детерминистически из порождающего элемента (seed number), но рассредоточены в статистическом сходстве с случайным образом. Для генерации NumPy использует особенный алгоритм который имеет название Mersenne Twister.
Задать порождающий элемент последовательности случайных чисел можно так: 



```python
np.random.seed(293423)
```

Seed это целое число. Каждая программа которая запускается с одинаковым seed`ом будет генерировать одинаковую последовательность чисел каждый раз. Это может быть полезно для отладки, но вообще нам не нужно задавать seed, на самом деле, когда мы запускаем программу несколько раз, мы хотим получать каждый раз разную последовательность чисел. Если эта команда не будет выполнена, то NumPy автоматически выбирает случайный seed (базирующийся на времени), который является разным при каждом запуске программы.
Массив случайных чисел из полуинтервала [0.0, 1.0) может быть сгенерирован так:


```python
np.random.rand(5)
```




    array([0.33677247, 0.52693437, 0.79529578, 0.78867702, 0.02147624])



Функция rand может быть использована для генерации двумерных массивов, или можно использовать функцию reshape:



```python
np.random.rand(2,3)
```




    array([[0.84612516, 0.0704939 , 0.1526965 ],
           [0.77831701, 0.80821151, 0.82198398]])




```python
np.random.rand(6).reshape((2,3))
```




    array([[0.90239653, 0.8385685 , 0.02638565],
           [0.33681448, 0.46480928, 0.61686496]])



Для генерации единичного случайного числа на интервале [0.0, 1.0):


```python
np.random.random()
```




    0.43767262538051455




Для генерации случайного целочисленного числа в диапазоне [min, max) используем функцию randint(min, max):


```python
np.random.randint(5, 10)
```




    9



#### Некоторая дополнительная информация

NumPy включает еще много других функций о которых мы не упоминали здесь. В частности это функции для работы с дискретным преобразованием Фурье, более сложными операциями в линейной алгебре, тестированием массивов на размер / размерность / тип, разделением и соединением массивов, гистограммами, создания массивов из каких-либо данных разными путями, созданием и оперированием grid-массивов, специальными значениями (NaN, Inf), set-операции, созданием разных видов специальных матриц и вычислением специальных математических функций (Например: функции Бесселя). Также вы можете посмотреть документацию NumPy для более точных деталей. 
